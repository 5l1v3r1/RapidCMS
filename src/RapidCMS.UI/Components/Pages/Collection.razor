@inherits BasePage

@layout MainLayout

@page "/{Action}/{CollectionAlias}"
@page "/{Action}/{Path}/{CollectionAlias}"

@if (RootEditContext == null || ListUI == null)
{
    <div class="content">
        <p>Loading..</p>
    </div>
}
else
{
    <CascadingEditContext EditContext=@RootEditContext>
        <Tabbar Tabs="Tabs" SearchBarVisible="ListUI.SearchBarVisible" OnSearch="SearchAsync" OnTabChange="TabChangeAsync" />
        <ButtonBar Buttons="Buttons" OnButtonClick="ListButtonOnClickAsync" />
    </CascadingEditContext>

    @if (Sections != null)
    {
        @if (ListUI.ListType == ListType.Table)
        {
            <TableSection UI="ListUI"
                          Sections="Sections"
                          CurrentPage="CurrentPage"
                          MaxPage="MaxPage"
                          OnButtonClick="NodeButtonOnClickAsync"
                          OnPageChanged="PageChangedAsync" />
        }
        else if (ListUI.ListType == ListType.Block)
        {
            <BlocksSection Sections="Sections"
                           CurrentPage="CurrentPage"
                           MaxPage="MaxPage"
                           OnButtonClick="NodeButtonOnClickAsync"
                           OnPageChanged="PageChangedAsync" />
        }
    }
}
@code {

    [Inject] private IEditContextService EditContextService { get; set; }
    [Inject] private IEditorService EditorService { get; set; }

    EditContext? RootEditContext;

    IEnumerable<ButtonUI>? Buttons;
    IEnumerable<(EditContext editContext, IEnumerable<SectionUI> sections)>? Sections;
    IEnumerable<TabUI>? Tabs;

    IListUIResolver? UIResolver;
    ListUI? ListUI;

    int? ActiveTab = null;
    string? SearchTerm = null;
    int CurrentPage = 1;
    int? MaxPage = null;

    protected override async Task LoadDataAsync(IEnumerable<string>? reloadEntityIds = null)
    {
        try
        {
            if (reloadEntityIds == null)
            {
                var parentPath = GetParentPath();

                var rootEditContext = await EditContextService.GetRootAsync(GetUsageType(), CollectionAlias, parentPath);

                UIResolver = await EditorService.GetListUIResolverAsync(GetUsageType(), CollectionAlias);

                Buttons = await UIResolver.GetButtonsForEditContextAsync(rootEditContext);
                Tabs = await UIResolver.GetTabsAsync(rootEditContext);

                CurrentPage = 1;
                MaxPage = null;
                ActiveTab = null;
                SearchTerm = null;

                await LoadSectionsAsync();

                RootEditContext = rootEditContext;
                Sections?.ForEach(x => x.editContext.OnFieldChanged += (s, a) => StateHasChanged());
            }
            else
            {
                await ReloadSectionsAsync(reloadEntityIds);
            }

            StateHasChanged();
        }
        catch
        {
            RootEditContext = null;
            Sections = null;
            ListUI = null;

            throw;
        }
    }

    async void PageChangedAsync(int page)
    {
        CurrentPage = page;

        await LoadSectionsAsync();
        StateHasChanged();
    }

    async void SearchAsync(string? search)
    {
        CurrentPage = 1;

        SearchTerm = search;

        await LoadSectionsAsync();
        StateHasChanged();
    }

    async void TabChangeAsync(int? tabId)
    {
        ActiveTab = tabId;

        CurrentPage = 1;

        await LoadSectionsAsync();
        StateHasChanged();
    }

    async Task LoadSectionsAsync()
    {
        if (UIResolver == null)
        {
            return;
        }

        ListUI = UIResolver.GetListDetails();

        var query = Query.Create(ListUI.PageSize, CurrentPage, SearchTerm, ActiveTab);

        var editContexts = await EditContextService.GetEntitiesAsync(GetUsageType(), CollectionAlias, GetParentPath(), query);
        Sections = await editContexts.ToListAsync(async editContext => (editContext, await UIResolver.GetSectionsForEditContextAsync(editContext)));

        if (!query.MoreDataAvailable)
        {
            MaxPage = CurrentPage;

            if (CurrentPage > 1 && !Sections.Any())
            {
                CurrentPage--;
                MaxPage = null;
                await LoadSectionsAsync();
            }
        }
        if (MaxPage == CurrentPage && query.MoreDataAvailable)
        {
            MaxPage = null;
        }
    }

    async Task ReloadSectionsAsync(IEnumerable<string> reloadEntityIds)
    {
        if (UIResolver == null || Sections == null)
        {
            return;
        }

        var newSections = await Sections.ToListAsync(async x =>
        {
            if (reloadEntityIds.Contains(x.editContext.Entity.Id))
            {
                var reloadedEditContext = await EditContextService.GetEntityAsync(x.editContext.UsageType, CollectionAlias, null, GetParentPath(), x.editContext.Entity.Id);
                return (reloadedEditContext, await UIResolver.GetSectionsForEditContextAsync(reloadedEditContext));
            }
            else
            {
                return x;
            }
        });

        Sections = newSections;
    }

    async void ListButtonOnClickAsync(object? sender, ButtonClickEventArgs args)
    {
        var model = sender as ButtonViewModel;

        try
        {
            if (model == null)
            {
                throw new ArgumentException($"Argument must be of type {typeof(ButtonViewModel)}.", nameof(sender));
            }

            var command = await EditContextService.ProcessListActionAsync(GetUsageType(), CollectionAlias, GetParentPath(), Sections.Select(x => x.editContext), model.ButtonId, args.Data);

            await HandleViewCommandAsync(command);
        }
        catch (Exception ex)
        {
            HandleException(ex);
        }
    }

    async void NodeButtonOnClickAsync(object? sender, ButtonClickEventArgs args)
    {
        var model = sender as ButtonViewModel;

        try
        {
            if (model == null)
            {
                throw new ArgumentException($"Argument must be of type {typeof(ButtonViewModel)}.", nameof(sender));
            }

            var command = await EditContextService.ProcessListActionAsync(args.EditContext.UsageType, CollectionAlias, GetParentPath(), args.EditContext.Entity.Id, args.EditContext, model.ButtonId, args.Data);

            await HandleViewCommandAsync(command);
        }
        catch (Exception ex)
        {
            HandleException(ex);
        }
    }
}
